#AUTOGENERATED! DO NOT EDIT! File to edit: dev/Days.ipynb (unless otherwise specified).

__all__ = ['BaseDays', 'Days', 'NotDays']

#Cell
class BaseDays(pd.DataFrame):
    def __init__(self, data, y_names, cat_var=None, con_var=None, cats={}, **kw):
        super(BaseDays, self).__init__(data, **kw)

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            self.con_var, self.y_names = L(con_var), L(y_names)
            self.set_index("datetime", drop=False, inplace=True)

            self.cols = ["datetime"] + self.con_var
            self.cat_var = L(ifnone(cat_var, cats.keys()))
            self.cats = cats

        if cats == {}:
            for cat_var in self.cat_var:
                self.cats[cat_var] = self[cat_var].iloc[0]
        else:
            for k, v in cats.items():
                self.loc[:, k] = v
        for c in self.cols + self.y_names:
            if c not in self.columns:
                print(f"Warning {c} not in {self.columns} of {self.__class__}")

    def copy(self):
        # https://stackoverflow.com/questions/17591104/in-pandas-can-i-deeply-copy-a-dataframe-including-its-index-and-column
        #         print('copy made ',self.__class__)
        return self.__class__(
            pd.DataFrame(self.values.copy(), self.index.copy(), self.columns.copy()),
            self.y_names.copy(),
            self.cat_var.copy(),
            self.con_var.copy(),
        )


#Cell
class Days(BaseDays):
    def show(self, plot=True, **kwargs):

        title = f"{self.cats}  from {str(min(self.df.loc[:,'datetime']))} to {str(max(self.df.loc[:,'datetime']))} #{self.df.shape[0]}"
        print(self.df.columns)
        if plot:
            plot_days(
                self.df,
                left=self.con_var,
                right=self.y_names + ["pred"],
                title=title,
                **kwargs,
            )
        else:
            return title + "\n" + str(self.df.head(1))

    @classmethod
    def from_ndays(cls, nday):
        cats = {} if not hasattr(nday, "cats") else nday.cats
        return cls(nday.df, nday.y_names, nday.cat_var, nday.con_var, cats=cats)


#Cell
class NotDays(BaseDays):
    @classmethod
    def from_days(cls, day):
        cats = {} if not hasattr(day, "cats") else day.cats
        return cls(day.df, day.y_names, day.cat_var, day.con_var, cats=cats)
